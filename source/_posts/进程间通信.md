# IPC进程间通信

概念：**进程间通信**是指在[并行计算](https://wiki.mbalib.com/wiki/并行计算)过程中,各进程之间进行[数据](https://wiki.mbalib.com/wiki/数据)交互或消息传递, 和各个执行进程之间的相对独立性。也就是在多进程环境下,使用的数据交互、事件通知等方法使各进程协同工作。

-   进程之间的[信息传递](https://wiki.mbalib.com/wiki/信息传递)不可能通过变量或其它[数据结构](https://wiki.mbalib.com/wiki/数据结构)直接进行，只能通过进程间通信来完成。

-   常见的高级通信有管道([PIPE](https://wiki.mbalib.com/wiki/PIPE))、消息队列(MESSAGE)、共享内存(SHARED MEM0RY)等。

-   进程间通信主要包括管道,系统IPC(Inter-Process Communication，进程间通信)(包括消息队列,[信号](https://wiki.mbalib.com/wiki/信号),共享存储), 套接字(SOCKET)。管道包括三种:

1.  普通管道PIPE, 通常有两种限制,一是单工,只能单向传输;二是只能在父子或者兄弟进程间使用。
2.  流管道s_pipe: 去除了第一种限制,为半双工，可以双向传输。
3.  命名管道:name_pipe, 去除了第二种限制,可以在许多并[不相关](https://wiki.mbalib.com/wiki/不相关)的进程之间进行[通讯](https://wiki.mbalib.com/wiki/通讯)。

## 1. 进程间通信使用的目的

1.  [数据传输](https://wiki.mbalib.com/wiki/数据传输)：一个进程需要将它的[数据](https://wiki.mbalib.com/wiki/数据)[发送](https://wiki.mbalib.com/wiki/发送)给另一个进程，发送的数据量在一个字节到几[兆字节](https://wiki.mbalib.com/wiki/兆字节)之间。
2.  共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程[应该](https://wiki.mbalib.com/wiki/应该)立刻看到。
3.  通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
4.  资源共享：多个进程之间共享同样的[资源](https://wiki.mbalib.com/wiki/资源)。为了做到这一点，[需要](https://wiki.mbalib.com/wiki/需要)内核提供锁和同步机制。
5.  进程控制：有些进程希望完全[控制](https://wiki.mbalib.com/wiki/控制)另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

　　进程通过与内核及其它进程之间的互相通信来[协调](https://wiki.mbalib.com/wiki/协调)它们的[行为](https://wiki.mbalib.com/wiki/行为)。如[Linux](https://wiki.mbalib.com/wiki/Linux)支持多种进程间通信（IPC）机制，[信号](https://wiki.mbalib.com/wiki/信号)和管道是其中的两种。除此之外，Linux还支持System V的IPC机制（用首次出现的Unix版本命名）。

## 2.进程间使用通信的技术点

进程间通信是同一台处理机或不同处理机的多个进程间传送[数据](https://wiki.mbalib.com/wiki/数据)或[消息](https://wiki.mbalib.com/wiki/消息)的一些[技术](https://wiki.mbalib.com/wiki/技术)或方法，方式有：

-   管道（pipe）及有名管道（named pipe）： 

　　管道可用于具有亲缘关系进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。  

-   [信号](https://wiki.mbalib.com/wiki/信号)（[signal](https://wiki.mbalib.com/wiki/Signal)）： 

　　[信号](https://wiki.mbalib.com/wiki/信号)是一种软中断，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。  

-   消息队列（message queue）： 

　　消息队列是[消息](https://wiki.mbalib.com/wiki/消息)的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限的进程可以按照一定的规则向消息队列中添加新[信息](https://wiki.mbalib.com/wiki/信息)；对消息队列有读权限的进程则可以从消息队列中读取[信息](https://wiki.mbalib.com/wiki/信息)。  

-   共享内存（shared memory）： 

　　可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中[数据](https://wiki.mbalib.com/wiki/数据)的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。  

-   信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。  
-   套接字（socket）；这是一种更为一般的进程间通信机制，它可用于[网络](https://wiki.mbalib.com/wiki/网络)中不同机器之间的进程间通信，应用非常广泛。

## 3. 进程通信特点

-   进程通信：在用户空间实现进程通信是**不可能**的，通过linux内核通信。

-   线程间通信：可以在用户空间就实现，通过**全局变量**来实现。

-   通信方式：

    >   *   管道通信：无名管道、有名管道（文件系统中有）。
    >
    >   *   信号通信：信号（通知）通信包括：信号的发送、信号的接收、信号的处理。
    >
    >   *   IPC通信：共享内存、消息队列和信号灯。
    >
    >       以上是**单机模式**下的进程通信（只有一个Linux内核）
    >
    >   *   socket通信：存在与一个网络中两个进程之间的通信（**两个Linux内核**）
    >
    >   *   信号与信号量的区别是：信号只是对单个信号量的操作，而信号量则是对多个信号量集合的操作；



### 3.1 信号

-   函数 void (\*signal(int sig, void (\*handler)(int))) (int);

    void (\*handler)(int) 是个函数指针  

    信号处理函数一般具有： void handler(int sig){}; sig表示信号值

-   exit(0) 发出的信号是 SIGCHILD的信号；

-   wait(NULL) 父进程回收子进程，可以使用signal信号+函数来处理，不然会一直阻塞；

-   sigaction的使用比signal更具有移植性；

```c
#include "dong.h"

void func(int signum)
{
    printf("recv signal:[%d]\n", signum);
    return ;
}

void func1(int signum)
{
    printf("exit sign:[%d]\n", signum);
    wait(NULL);

    return ;
}

int main()
{
    int i = 0;

    pid_t pid;

    signal(SIGUSR1, func); /*处理kill信号*/
    signal(SIGCHLD, func1); /*处理exit(0)的信号*/

    pid = fork();
    if (pid < 0)
    {
        printf("fork error.\n");
        return -1;
    }

    if (pid > 0)
    {
        while (1)
        {
            printf("parent process thing, i:[%d]\n", i);
            sleep(1);
            i++;
        }
        
    }else
    {
        sleep(10);
        kill(getppid(),0);
        exit(0);
    }
    
    return 0;
}
```



### 3.2 共享内存

-   ipcs 查看创建的IPC对象：

    ipcs -m 查看创建的内存   ipcs -q 查看创建的队列  ipcs -s 查看创建的信号灯

-   函数 key_t ftok(const char *pathname, int proj_id); 

    返回值：key 参数：路径，字符。 

-   函数 int shmget(key_t key, size_t size, int shmflg); 

    返回值：shmid 参数：ftok返回的key，或者 IPC_PRIVATE 只能用于有亲缘关系；共享内存的大小；shmflag表示权限 IPC_CREAT|IPC_EXCL|0666;

    shmget创建共享内存成功后，再次创建会报错 EEXIST;

```c
#include "dong.h"

int main()
{
    int shmid;
    char cmd[128] = {0};

    key_t key;
    key = ftok(".", 'x');
    if (key < 0)
    {
        printf("ftok error. msg:[%s]\n", strerror(errno));
        return -1;
    }

    shmid = shmget(key, 128, IPC_CREAT|IPC_EXCL|0666);
    if (errno == EEXIST)
    {
        shmid = shmget(key, 0, 0); /*重复了，需要重新获取id号*/
    }

    if (shmid < 0)
    {
        printf("shmget error. msg:[%s]\n", strerror(errno));
        return -1;
    }
    printf("shmid:[%d]\n", shmid);
    system("ipcs -m");
    
    
    system("ipcs -m");
    return 0;
}
```

-   函数 int shmdt(const void *shmaddr); 

    shmaddr 映射后的地址，将进程里的地址映射删除 （**就是将用户空间的共享内存地址删除**）；

-   函数 int shmctl(int shmid, int cmd, struct shmid_ds *buf); 删除内核空间的共享内存地址  成功：0 出错-1

    shmid:要操作的共享内存标识符

    cmd: IPC_STAT (获取对象属性)

    ​         IPC_SET(设置对象属性)

    ​         IPC_RMID(删除对象)

    buf:指定IPC_STAT/IPC_SET是用以保存/设置属性
